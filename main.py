import logging
import asyncio
import datetime
from dotenv import load_dotenv
import os
import psycopg2
from psycopg2.extras import RealDictCursor
from aiogram import Bot, Dispatcher, types, Router, F
from aiogram.fsm.context import FSMContext
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.state import State, StatesGroup
from aiogram.filters import Command
from aiogram.exceptions import TelegramBadRequest, TelegramForbiddenError
from aiogram.enums.chat_member_status import ChatMemberStatus
import aiohttp

logging.basicConfig(level=logging.INFO)
load_dotenv()

BOT_TOKEN = os.getenv("BOT_TOKEN")
CRYPTO_BOT_TOKEN = os.getenv("CRYPTO_BOT_TOKEN")
GROUP_ID = int(os.getenv("GROUP_ID"))
MODERATOR_GROUP_ID = int(os.getenv("MODERATOR_GROUP_ID"))
SUPPORT_CONTACT = os.getenv("SUPPORT_CONTACT", "@vextrsupport")
DB_HOST = os.getenv("DB_HOST")
DB_NAME = os.getenv("DB_NAME")
DB_USER = os.getenv("DB_USER")
DB_PASSWORD = os.getenv("DB_PASSWORD")
DB_PORT = os.getenv("DB_PORT", "5432")

bot = Bot(token=BOT_TOKEN)
storage = MemoryStorage()
dp = Dispatcher(storage=storage)
router = Router()
dp.include_router(router)

try:
    conn = psycopg2.connect(
        host=DB_HOST,
        database=DB_NAME,
        user=DB_USER,
        password=DB_PASSWORD,
        port=DB_PORT,
        cursor_factory=RealDictCursor
    )
    cursor = conn.cursor()
    print("Database connection established successfully.")
except Exception as e:
    logging.error(f"Database connection error: {e}")
    raise

cursor.execute("""
    CREATE TABLE IF NOT EXISTS users (
        user_id BIGINT PRIMARY KEY,
        chat_id BIGINT,
        subscription_end TIMESTAMP,
        subscription_type TEXT,
        referral_uuid TEXT,
        api_key TEXT,
        secret_key TEXT,
        passphrase TEXT,
        exchange TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
""")
cursor.execute("""
    CREATE TABLE IF NOT EXISTS payments (
        invoice_id BIGINT PRIMARY KEY,
        user_id BIGINT,
        amount REAL,
        currency TEXT,
        status TEXT,
        tariff_id TEXT,
        FOREIGN KEY (user_id) REFERENCES users (user_id)
    )
""")

# –ü—Ä–æ–≤–µ—Ä–∫–∏ –∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å—Ç–æ–ª–±—Ü–æ–≤ –¥–ª—è users
cursor.execute("""
    SELECT column_name 
    FROM information_schema.columns 
    WHERE table_name = 'users' AND column_name = 'chat_id';
""")
if not cursor.fetchone():
    logging.info("Adding chat_id column to users table...")
    cursor.execute("ALTER TABLE users ADD COLUMN chat_id BIGINT;")
    conn.commit()
    logging.info("Column chat_id added to users table.")

cursor.execute("""
    SELECT column_name 
    FROM information_schema.columns 
    WHERE table_name = 'users' AND column_name = 'passphrase';
""")
if not cursor.fetchone():
    logging.info("Adding passphrase column to users table...")
    cursor.execute("ALTER TABLE users ADD COLUMN passphrase TEXT;")
    conn.commit()
    logging.info("Column passphrase added to users table.")

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å—Ç–æ–ª–±—Ü–∞ tariff_id –¥–ª—è payments
cursor.execute("""
    SELECT column_name 
    FROM information_schema.columns 
    WHERE table_name = 'payments' AND column_name = 'tariff_id';
""")
if not cursor.fetchone():
    logging.info("Adding tariff_id column to payments table...")
    cursor.execute("ALTER TABLE payments ADD COLUMN tariff_id TEXT;")
    conn.commit()
    logging.info("Column tariff_id added to payments table.")

conn.commit()

TARIFFS = {
    'test': {'days': 1, 'price': 1, 'name': '–¢–µ—Å—Ç–æ–≤—ã–π (1 –¥–µ–Ω—å)'},
    '1month': {'days': 30, 'price': 6, 'name': '1 –º–µ—Å—è—Ü'},
    '3months': {'days': 90, 'price': 15, 'name': '3 –º–µ—Å—è—Ü–∞'},
}

class PaymentStates(StatesGroup):
    waiting_for_agreement = State()
    waiting_for_subscription_type = State()
    waiting_for_exchange = State()
    waiting_for_referral_uuid = State()
    waiting_for_payment = State()
    waiting_for_api_key = State()
    waiting_for_secret_key = State()
    waiting_for_passphrase = State()

async def create_invoice(user_id, amount, description, tariff_id):
    async with aiohttp.ClientSession() as session:
        url = "https://pay.crypt.bot/api/createInvoice"
        headers = {"Crypto-Pay-API-Token": CRYPTO_BOT_TOKEN}
        params = {
            "asset": "USDT",
            "amount": amount,
            "description": description,
            "hidden_message": "–°–ø–∞—Å–∏–±–æ –∑–∞ –æ–ø–ª–∞—Ç—É!",
            "payload": f"user_{user_id}_{tariff_id}"
        }
        try:
            async with session.get(url, headers=headers, params=params) as response:
                if response.status != 200:
                    logging.error(f"CryptoBot API error: {response.status} - {await response.text()}")
                    return None
                invoice_data = await response.json()
                if invoice_data.get("ok") and invoice_data.get("result"):
                    return invoice_data["result"]
                else:
                    logging.error(f"Invalid CryptoBot response: {invoice_data}")
                    return None
        except aiohttp.ClientError as e:
            logging.error(f"Network error creating invoice for user {user_id}: {e}")
            return None

def get_subscription_type_keyboard():
    keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
        [types.InlineKeyboardButton(text="–û–±—ã—á–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞", callback_data="subscription:regular")],
        [types.InlineKeyboardButton(text="–†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞", callback_data="subscription:referral")],
        [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
    ])
    return keyboard

def get_tariffs_keyboard():
    keyboard = types.InlineKeyboardMarkup(inline_keyboard=[])
    for tariff_id, tariff in TARIFFS.items():
        keyboard.inline_keyboard.append([types.InlineKeyboardButton(
            callback_data=f"tariff:{tariff_id}",
            text=f"{tariff['name']} - {tariff['price']}$"
        )])
    keyboard.inline_keyboard.append([types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")])
    return keyboard

def get_exchange_keyboard():
    keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
        [types.InlineKeyboardButton(text="BingX", callback_data="exchange:bingx"),
         types.InlineKeyboardButton(text="OKX", callback_data="exchange:okx")],
        [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
    ])
    return keyboard

def get_main_menu(user_id):
    buttons = [[types.KeyboardButton(text="–ü–æ–¥–∫–ª—é—á–∏—Ç—å API")]]
    cursor.execute("SELECT subscription_end FROM users WHERE user_id = %s", (user_id,))
    result = cursor.fetchone()
    if result and result['subscription_end'] is not None and result['subscription_end'] > datetime.datetime.now():
        buttons.append([types.KeyboardButton(text="–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–¥–ø–∏—Å–∫–µ")])
    buttons.append([types.KeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞")])
    keyboard = types.ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True, one_time_keyboard=False)
    return keyboard

async def is_bot_in_group():
    try:
        print(f"Checking bot in group: {GROUP_ID}")
        member = await bot.get_chat_member(chat_id=GROUP_ID, user_id=bot.id)
        return member.status in [ChatMemberStatus.MEMBER, ChatMemberStatus.ADMINISTRATOR]
    except TelegramForbiddenError:
        logging.error("–ë–æ—Ç –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω –≤ –≥—Ä—É–ø–ø—É –∏–ª–∏ –Ω–µ –∏–º–µ–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")
        return False
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è –±–æ—Ç–∞ –≤ –≥—Ä—É–ø–ø–µ: {e}")
        return False

VIDEO_INSTRUCTIONS = {
    'bingx': 'videos/bingx.mp4',
    'okx': 'videos/okx.mp4'
}

@router.message(Command("start"))
async def cmd_start(message: types.Message, state: FSMContext):
    is_in_group = await is_bot_in_group()
    if not is_in_group:
        keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
        ])
        await message.answer(
            "‚ùå –ë–æ—Ç –Ω–µ —Å–æ—Å—Ç–æ–∏—Ç –≤ –≥—Ä—É–ø–ø–µ –∏–ª–∏ –Ω–µ –∏–º–µ–µ—Ç –¥–æ—Å—Ç—É–ø–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–±–∞–≤—å—Ç–µ –±–æ—Ç–∞ –≤ –≥—Ä—É–ø–ø—É –∏ –Ω–∞–∑–Ω–∞—á—å—Ç–µ –µ–≥–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.",
            reply_markup=keyboard
        )
        return

    user_id = message.from_user.id
    cursor.execute("SELECT subscription_end, subscription_type FROM users WHERE user_id = %s", (user_id,))
    result = cursor.fetchone()

    welcome_text = (
        "üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ —Ç–æ—Ä–≥–æ–≤–æ–≥–æ –±–æ—Ç–∞ VEXTR!\n\n"
        "–≠—Ç–æ—Ç –±–æ—Ç –ø–æ–º–æ–≥–∞–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∏—Ä–æ–≤–∞—Ç—å –≤–∞—à–∏ —Ç–æ—Ä–≥–æ–≤—ã–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –Ω–∞ BingX –∏–ª–∏ OKX.\n"
        "‚ö†Ô∏è –¢–æ—Ä–≥–æ–≤–ª—è –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–æ–π —Å–≤—è–∑–∞–Ω–∞ —Å —Ä–∏—Å–∫–∞–º–∏.\n\n"
        "üìÑ –ü–µ—Ä–µ–¥ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –æ–∑–Ω–∞–∫–æ–º—å—Ç–µ—Å—å —Å —É—Å–ª–æ–≤–∏—è–º–∏:\n"
        "üëâ https://telegra.ph/POLZOVATELSKOE-SOGLASHENIE-PUBLICHNAYA-OFERTA-10-05\n\n"
        "–ü—Ä–æ–¥–æ–ª–∂–∞—è, –≤—ã –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç–µ —Å–æ–≥–ª–∞—Å–∏–µ —Å –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–º —Å–æ–≥–ª–∞—à–µ–Ω–∏–µ–º."
    )
    keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
        [types.InlineKeyboardButton(text="‚úÖ –°–æ–≥–ª–∞—Å–∏—Ç—å—Å—è", callback_data="agree")],
        [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
    ])
    await message.answer(welcome_text, reply_markup=keyboard, parse_mode="HTML")
    await state.set_state(PaymentStates.waiting_for_agreement)

@router.callback_query(F.data == "agree")
async def process_agreement(callback_query: types.CallbackQuery, state: FSMContext):
    user_id = callback_query.from_user.id
    await callback_query.answer()

    cursor.execute("SELECT subscription_end, subscription_type FROM users WHERE user_id = %s", (user_id,))
    result = cursor.fetchone()

    if not result:
        await callback_query.message.edit_text(
            "–î–∞–Ω–Ω—ã–π –±–æ—Ç –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –≤–∞–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –≤–µ—Ä—Å–∏–µ–π –Ω–∞—à–µ–π —Ç–æ—Ä–≥–æ–≤–æ–π —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –±–µ–∑ –Ω–∞–¥–æ–±–Ω–æ—Å—Ç–∏ –≤—ã—Ö–æ–¥–∏—Ç—å –∑–∞ –ø—Ä–µ–¥–µ–ª—ã Telegram.\n"
            "–í–∞–º –æ—Å—Ç–∞–µ—Ç—Å—è –ª–∏—à—å –æ–¥–∏–Ω —Ä–∞–∑ –ø—Ä–æ–≤–µ—Å—Ç–∏ –Ω–µ–±–æ–ª—å—à—É—é –Ω–∞—Å—Ç—Ä–æ–π–∫—É, –ø–æ—Å–ª–µ —á–µ–≥–æ –≤—ã —Å–º–æ–∂–µ—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–µ–π –∏ —Å –ø–æ–º–æ—â—å—é —ç—Ç–æ–≥–æ –±–æ—Ç–∞.\n"
            "–î–ª—è –Ω–∞—á–∞–ª–∞ –≤–∞–º –Ω—É–∂–Ω–æ –≤—ã–±—Ä–∞—Ç—å —Ç–∏–ø –≤–∞—à–µ–π –ø–æ–¥–ø–∏—Å–∫–∏",
            reply_markup=get_subscription_type_keyboard()
        )
        await state.set_state(PaymentStates.waiting_for_subscription_type)
    else:
        subscription_end = result['subscription_end']
        subscription_type = result['subscription_type']
        if subscription_type == "referral_approved" and subscription_end is not None and subscription_end > datetime.datetime.now():
            await callback_query.message.edit_text(
                f"‚úÖ –í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ –∞–∫—Ç–∏–≤–Ω–∞ –¥–æ <b>{subscription_end.strftime('%Y-%m-%d %H:%M:%S')}</b>",
                parse_mode="HTML",
                reply_markup=get_main_menu(user_id)
            )
            await state.clear()
        elif subscription_type == "referral_pending":
            keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
                [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
            ])
            await callback_query.message.edit_text(
                "‚è≥ –í–∞—à UUID –Ω–∞ –º–æ–¥–µ—Ä–∞—Ü–∏–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–∂–¥–∏—Ç–µ—Å—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.",
                reply_markup=keyboard
            )
        else:
            await callback_query.message.edit_text(
                "‚ùóÔ∏è –í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ –∏—Å—Ç–µ–∫–ª–∞ –∏–ª–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Ç–∞—Ä–∏—Ñ:",
                reply_markup=get_tariffs_keyboard()
            )
            await state.set_state(PaymentStates.waiting_for_payment)

@router.callback_query(F.data.startswith("subscription:"))
async def process_subscription_type(callback_query: types.CallbackQuery, state: FSMContext):
    subscription_type = callback_query.data.split(":")[1]
    user_id = callback_query.from_user.id
    await callback_query.answer()

    cursor.execute("SELECT subscription_type FROM users WHERE user_id = %s", (user_id,))
    result = cursor.fetchone()

    if subscription_type == "referral":
        if result and result['subscription_type'] == "referral_approved":
            await callback_query.message.edit_text(
                "‚úÖ –£ –≤–∞—Å —É–∂–µ –µ—Å—Ç—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω–Ω–∞—è —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞. –í—ã–±–µ—Ä–∏—Ç–µ –±–∏—Ä–∂—É –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è API:",
                reply_markup=get_exchange_keyboard()
            )
            await state.set_state(PaymentStates.waiting_for_api_key)
            return
        elif result and result['subscription_type'] == "referral_pending":
            keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
                [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
            ])
            await callback_query.message.edit_text(
                "‚è≥ –í–∞—à –ø—Ä–µ–¥—ã–¥—É—â–∏–π UUID –µ—â—ë –Ω–∞ –º–æ–¥–µ—Ä–∞—Ü–∏–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–∂–¥–∏—Ç–µ—Å—å –æ—Ç–≤–µ—Ç–∞.",
                reply_markup=keyboard
            )
            return
        await callback_query.message.edit_text(
            "–í—ã–±–µ—Ä–∏—Ç–µ –±–∏—Ä–∂—É –¥–ª—è —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–æ–π –ø–æ–¥–ø–∏—Å–∫–∏:",
            reply_markup=get_exchange_keyboard()
        )
        await state.update_data(subscription_type=subscription_type, user_id=user_id)
        await state.set_state(PaymentStates.waiting_for_exchange)
    else:
        cursor.execute(
            "INSERT INTO users (user_id, chat_id, subscription_type) VALUES (%s, %s, %s) ON CONFLICT (user_id) DO UPDATE SET chat_id = %s, subscription_type = %s",
            (user_id, user_id, "regular", user_id, "regular")
        )
        conn.commit()
        await callback_query.message.edit_text(
            "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∞—Ä–∏—Ñ –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏:",
            reply_markup=get_tariffs_keyboard()
        )
        await state.update_data(subscription_type="regular")
        await state.set_state(PaymentStates.waiting_for_payment)

@router.callback_query(F.data.startswith("tariff:"))
async def process_tariff_selection(callback_query: types.CallbackQuery, state: FSMContext):
    tariff_id = callback_query.data.split(":")[1]
    user_id = callback_query.from_user.id
    await callback_query.answer()

    if tariff_id not in TARIFFS:
        keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
        ])
        await callback_query.message.edit_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ç–∞—Ä–∏—Ñ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Å–Ω–æ–≤–∞:",
                                              reply_markup=keyboard)
        return

    tariff = TARIFFS[tariff_id]
    amount = tariff['price']
    description = f"–û–ø–ª–∞—Ç–∞ –ø–æ–¥–ø–∏—Å–∫–∏: {tariff['name']}"
    logging.info(f"Creating invoice for user {user_id}, tariff: {tariff_id}, amount: {amount}")

    invoice = await create_invoice(user_id, amount, description, tariff_id)
    if not invoice:
        keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
        ])
        await callback_query.message.edit_text(
            "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Å—á—ë—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π.",
            reply_markup=keyboard
        )
        return

    invoice_id = invoice["invoice_id"]
    pay_url = invoice["pay_url"]

    cursor.execute(
        "INSERT INTO payments (invoice_id, user_id, amount, currency, status, tariff_id) VALUES (%s, %s, %s, %s, %s, %s)",
        (invoice_id, user_id, amount, "USDT", "pending", tariff_id)
    )
    conn.commit()

    keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
        [types.InlineKeyboardButton(text="üí≥ –û–ø–ª–∞—Ç–∏—Ç—å", url=pay_url)],
        [types.InlineKeyboardButton(text="–û—Ç–º–µ–Ω–∞", callback_data="cancel")],
        [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
    ])
    await callback_query.message.edit_text(
        f"üí∏ –°—á—ë—Ç –Ω–∞ {amount} USDT –¥–ª—è —Ç–∞—Ä–∏—Ñ–∞ '{tariff['name']}' —Å–æ–∑–¥–∞–Ω.\n"
        f"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–ø–ª–∞—Ç–∏—Ç–µ –ø–æ —Å—Å—ã–ª–∫–µ –Ω–∏–∂–µ:",
        reply_markup=keyboard
    )
    await state.update_data(tariff_id=tariff_id, invoice_id=invoice_id)
    await state.set_state(PaymentStates.waiting_for_payment)

@router.message(PaymentStates.waiting_for_payment)
async def remind_payment(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    data = await state.get_data()
    invoice_id = data.get('invoice_id')
    keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
        [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
    ])
    if invoice_id:
        cursor.execute("SELECT amount, tariff_id FROM payments WHERE invoice_id = %s", (invoice_id,))
        payment = cursor.fetchone()
        if payment:
            tariff = TARIFFS.get(payment['tariff_id'])
            await message.answer(
                f"‚è≥ –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≤–µ—Ä—à–∏—Ç–µ –æ–ø–ª–∞—Ç—É –Ω–∞ {payment['amount']} USDT –¥–ª—è —Ç–∞—Ä–∏—Ñ–∞ '{tariff['name']}' –ø–æ —Ä–∞–Ω–µ–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–π —Å—Å—ã–ª–∫–µ.",
                reply_markup=keyboard
            )
        else:
            await message.answer(
                "‚ùå –°—á—ë—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Ç–∞—Ä–∏—Ñ —Å–Ω–æ–≤–∞:",
                reply_markup=get_tariffs_keyboard()
            )
            await state.set_state(PaymentStates.waiting_for_payment)
    else:
        await message.answer(
            "‚ùå –°—á—ë—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Ç–∞—Ä–∏—Ñ —Å–Ω–æ–≤–∞:",
            reply_markup=get_tariffs_keyboard()
        )
        await state.set_state(PaymentStates.waiting_for_payment)

@router.callback_query(F.data.startswith("exchange:"))
async def process_exchange(callback_query: types.CallbackQuery, state: FSMContext):
    exchange = callback_query.data.split(":")[1]
    user_id = callback_query.from_user.id
    video_path = VIDEO_INSTRUCTIONS.get(exchange)

    if not video_path or not os.path.exists(video_path):
        logging.error(f"Video file for {exchange} not found at {video_path}")
        keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
        ])
        try:
            await callback_query.message.edit_text(
                "‚ùå –û—à–∏–±–∫–∞: –í–∏–¥–µ–æ–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–π –±–∏—Ä–∂–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π.",
                reply_markup=keyboard
            )
        except TelegramBadRequest:
            await bot.send_message(
                chat_id=user_id,
                text="‚ùå –û—à–∏–±–∫–∞: –í–∏–¥–µ–æ–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–π –±–∏—Ä–∂–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π.",
                reply_markup=keyboard
            )
        return

    try:
        file_size = os.path.getsize(video_path) / (1024 * 1024)
        if file_size > 50:
            logging.error(f"Video file {video_path} too large: {file_size} MB")
            keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
                [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
            ])
            await callback_query.message.edit_text(
                "‚ùå –û—à–∏–±–∫–∞: –í–∏–¥–µ–æ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏.",
                reply_markup=keyboard
            )
            return

        for attempt in range(3):
            try:
                await bot.send_video(
                    chat_id=user_id,
                    video=types.FSInputFile(video_path),
                    caption=f"üìπ –û–∑–Ω–∞–∫–æ–º—å—Ç–µ—Å—å —Å –≤–∏–¥–µ–æ–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–µ–π –ø–æ —Å–æ–∑–¥–∞–Ω–∏—é API-–∫–ª—é—á–∞ –¥–ª—è {exchange.upper()}:",
                    request_timeout=100
                )
                break
            except aiohttp.ClientError as e:
                logging.warning(f"Attempt {attempt + 1} failed for user {user_id}: {e}")
                if attempt == 2:
                    logging.error(f"All attempts to send video for {exchange} to user {user_id} failed")
                    keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
                        [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
                    ])
                    await bot.send_message(
                        chat_id=user_id,
                        text="‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –≤–∏–¥–µ–æ–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –∏–∑-–∑–∞ —Å–µ—Ç–µ–≤—ã—Ö –ø—Ä–æ–±–ª–µ–º. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –ø–æ–∑–∂–µ.",
                        reply_markup=keyboard
                    )
                    return
                await asyncio.sleep(2)

        keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(text="–û—Ç–º–µ–Ω–∞", callback_data="cancel")],
            [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
        ])
        await bot.send_message(
            chat_id=user_id,
            text="üìé –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à UUID —Å –±–∏—Ä–∂–∏ –¥–ª—è –º–æ–¥–µ—Ä–∞—Ü–∏–∏:",
            reply_markup=keyboard
        )
        await state.update_data(exchange=exchange)
        await state.set_state(PaymentStates.waiting_for_referral_uuid)
        logging.info(f"Exchange selected: {exchange} for user {user_id}, video sent: {video_path}")

    except TelegramForbiddenError:
        logging.error(f"User {user_id} blocked the bot")
        try:
            await bot.send_message(
                chat_id=MODERATOR_GROUP_ID,
                text=f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª –±–æ—Ç–∞ –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤–∏–¥–µ–æ –¥–ª—è {exchange}."
            )
        except Exception as mod_error:
            logging.error(f"Failed to notify moderator group about user {user_id} blocking bot: {mod_error}")
        try:
            await callback_query.message.edit_text(
                "‚ùå –í—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª–∏ –±–æ—Ç–∞. –†–∞–∑–±–ª–æ–∫–∏—Ä—É–π—Ç–µ, —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å."
            )
        except TelegramBadRequest:
            pass
    except TelegramBadRequest as e:
        logging.error(f"Telegram error sending video for {exchange} to user {user_id}: {e}")
        keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
        ])
        try:
            await bot.send_message(
                chat_id=user_id,
                text="‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –≤–∏–¥–µ–æ–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∏–ª–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π.",
                reply_markup=keyboard
            )
        except TelegramBadRequest:
            await bot.send_message(
                chat_id=MODERATOR_GROUP_ID,
                text=f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id} –∏–∑-–∑–∞ –æ—à–∏–±–∫–∏: {e}"
            )
    except Exception as e:
        logging.error(f"Unexpected error sending video for {exchange} to user {user_id}: {e}")
        keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
        ])
        try:
            await bot.send_message(
                chat_id=user_id,
                text="‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∏–ª–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π.",
                reply_markup=keyboard
            )
        except TelegramBadRequest:
            await bot.send_message(
                chat_id=MODERATOR_GROUP_ID,
                text=f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id} –∏–∑-–∑–∞ –æ—à–∏–±–∫–∏: {e}"
            )

@router.message(PaymentStates.waiting_for_referral_uuid)
async def process_referral_uuid(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    referral_uuid = message.text.strip()
    data = await state.get_data()
    exchange = data.get('exchange')
    logging.info(f"Processing UUID {referral_uuid} for user {user_id}, exchange: {exchange}")

    if len(referral_uuid) < 8:
        keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
        ])
        await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç UUID. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞:", reply_markup=keyboard)
        return

    cursor.execute("SELECT subscription_type, subscription_end, api_key FROM users WHERE user_id = %s", (user_id,))
    result = cursor.fetchone()
    if result and result['subscription_type'] == "referral_pending":
        keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
        ])
        await message.answer("‚è≥ –í–∞—à –ø—Ä–µ–¥—ã–¥—É—â–∏–π UUID –µ—â—ë –Ω–∞ –º–æ–¥–µ—Ä–∞—Ü–∏–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–∂–¥–∏—Ç–µ—Å—å –æ—Ç–≤–µ—Ç–∞.", reply_markup=keyboard)
        return
    elif result and result['subscription_type'] == "referral_approved" and result['subscription_end'] > datetime.datetime.now():
        if result['api_key']:
            await message.answer(
                "‚úÖ –£ –≤–∞—Å —É–∂–µ –µ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω–∞—è —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞ –∏ –ø–æ–¥–∫–ª—é—á—ë–Ω–Ω–∞—è –∞–≤—Ç–æ—Ç–æ—Ä–≥–æ–≤–ª—è. –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
                reply_markup=get_main_menu(user_id)
            )
        else:
            await message.answer(
                "‚úÖ –£ –≤–∞—Å —É–∂–µ –µ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω–∞—è —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞. –í–≤–µ–¥–∏—Ç–µ –≤–∞—à API-–∫–ª—é—á:",
                reply_markup=types.ReplyKeyboardRemove()
            )
            await state.set_state(PaymentStates.waiting_for_api_key)
        return

    cursor.execute(
        "INSERT INTO users (user_id, chat_id, subscription_type, referral_uuid, exchange) VALUES (%s, %s, %s, %s, %s) ON CONFLICT (user_id) DO UPDATE SET chat_id = %s, subscription_type = %s, referral_uuid = %s, exchange = %s",
        (user_id, user_id, "referral_pending", referral_uuid, exchange, user_id, "referral_pending", referral_uuid, exchange)
    )
    conn.commit()

    try:
        await bot.send_message(
            MODERATOR_GROUP_ID,
            f"–ù–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å –Ω–∞ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω—É—é –ø–æ–¥–ø–∏—Å–∫—É:\n"
            f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {user_id}\n"
            f"–ë–∏—Ä–∂–∞: {exchange.upper()}\n"
            f"UUID: {referral_uuid}\n"
            f"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –∏–ª–∏ –æ—Ç–∫–ª–æ–Ω–∏—Ç–µ –∑–∞–ø—Ä–æ—Å.",
            reply_markup=types.InlineKeyboardMarkup(inline_keyboard=[
                [types.InlineKeyboardButton(text="‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å", callback_data=f"approve_uuid:{user_id}")],
                [types.InlineKeyboardButton(text="‚ùå –û—Ç–∫–ª–æ–Ω–∏—Ç—å", callback_data=f"reject_uuid:{user_id}")]
            ])
        )
        keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
        ])
        await message.answer(
            "‚úÖ UUID –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ –º–æ–¥–µ—Ä–∞—Ü–∏—é. –û–∂–∏–¥–∞–π—Ç–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –æ—Ç –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞.",
            reply_markup=keyboard
        )
        await state.update_data(referral_uuid=referral_uuid)
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ UUID –º–æ–¥–µ—Ä–∞—Ç–æ—Ä—É: {e}")
        keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
        ])
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ UUID. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.", reply_markup=keyboard)
        await state.clear()

@router.callback_query(F.data.startswith("approve_uuid:") | F.data.startswith("reject_uuid:"))
async def process_moderator_decision(callback_query: types.CallbackQuery, state: FSMContext):
    try:
        logging.info(f"Processing callback: {callback_query.data}")
        action, user_id = callback_query.data.split(":")
        user_id = int(user_id)
        await callback_query.answer()

        if action == "approve_uuid":
            logging.info(f"Approving UUID for user {user_id}")
            subscription_end = datetime.datetime.now() + datetime.timedelta(days=365)
            cursor.execute(
                "UPDATE users SET subscription_type = %s, subscription_end = %s WHERE user_id = %s",
                ("referral_approved", subscription_end, user_id)
            )
            conn.commit()
            try:
                cursor.execute("SELECT api_key, exchange FROM users WHERE user_id = %s", (user_id,))
                result = cursor.fetchone()
                current_state = await state.get_state()
                logging.info(f"Current state for user {user_id} after UUID approval: {current_state}")
                if result['api_key']:
                    await bot.send_message(
                        user_id,
                        "‚úÖ –í–∞—à UUID –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–º! API-–∫–ª—é—á —É–∂–µ –ø–æ–¥–∫–ª—é—á—ë–Ω. –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
                        reply_markup=get_main_menu(user_id)
                    )
                    await state.clear()
                else:
                    await bot.send_message(
                        user_id,
                        '''
–î–ª—è —É—Å–ø–µ—à–Ω–æ–π –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏ –≤–∞–º –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–∏—Ç—å API-–∫–ª—é—á –∏ Secret Key —Å –≤–∞—à–µ–π –±–∏—Ä–∂–∏. 
–í–ê–ñ–ù–û! –ú—ã –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º –≤–∞—à–∏ –¥–∞–Ω–Ω—ã–µ –≤ –ª–∏—á–Ω—ã—Ö —Ü–µ–ª—è—Ö –∏ –Ω–µ –ø–µ—Ä–µ–¥–∞–µ–º –∏—Ö —Ç—Ä–µ—Ç—å–∏–º –ª–∏—Ü–∞–º! 
–í—Å–µ –¥–∞–Ω–Ω—ã–µ —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ –∑–∞—â–∏—â–µ–Ω–Ω–æ–π –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –∏ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫–æ–º–∞–Ω–¥ –Ω–∞ –±–∏—Ä–∂—É.
–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à API-–∫–ª—é—á:
''',
                        reply_markup=types.ReplyKeyboardRemove()
                    )
                    await state.update_data(exchange=result['exchange'])
                    await state.set_state(PaymentStates.waiting_for_api_key)
                await callback_query.message.edit_text(
                    f"–†–µ—à–µ–Ω–∏–µ –ø–æ UUID –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ"
                )
            except TelegramForbiddenError:
                logging.error(f"Cannot send message to user {user_id}: Bot is blocked")
                await callback_query.message.edit_text(
                    f"–†–µ—à–µ–Ω–∏–µ –ø–æ UUID –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ, –Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª –±–æ—Ç–∞"
                )
            except TelegramBadRequest as e:
                logging.error(f"Telegram error for user {user_id}: {e}")
                await callback_query.message.edit_text(
                    f"–†–µ—à–µ–Ω–∏–µ –ø–æ UUID –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ, –Ω–æ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ"
                )
        else:  # reject_uuid
            logging.info(f"Rejecting UUID for user {user_id}")
            cursor.execute(
                "UPDATE users SET subscription_type = %s, referral_uuid = NULL WHERE user_id = %s",
                ("rejected", user_id)
            )
            conn.commit()
            try:
                await bot.send_message(
                    user_id,
                    "‚ùå –í–∞—à UUID –æ—Ç–∫–ª–æ–Ω—ë–Ω –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–º. –í—ã –º–æ–∂–µ—Ç–µ –≤—ã–±—Ä–∞—Ç—å –æ–±—ã—á–Ω—É—é –ø–æ–¥–ø–∏—Å–∫—É –∏–ª–∏ –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞:",
                    reply_markup=get_subscription_type_keyboard()
                )
                await state.set_state(PaymentStates.waiting_for_subscription_type)
                await callback_query.message.edit_text(
                    f"–†–µ—à–µ–Ω–∏–µ –ø–æ UUID –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: –û—Ç–∫–ª–æ–Ω–µ–Ω–æ"
                )
            except TelegramForbiddenError:
                logging.error(f"Cannot send message to user {user_id}: Bot is blocked")
                await callback_query.message.edit_text(
                    f"–†–µ—à–µ–Ω–∏–µ –ø–æ UUID –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: –û—Ç–∫–ª–æ–Ω–µ–Ω–æ, –Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª –±–æ—Ç–∞"
                )
            except TelegramBadRequest as e:
                logging.error(f"Telegram error for user {user_id}: {e}")
                await callback_query.message.edit_text(
                    f"–†–µ—à–µ–Ω–∏–µ –ø–æ UUID –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: –û—Ç–∫–ª–æ–Ω–µ–Ω–æ, –Ω–æ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ"
                )
    except Exception as e:
        logging.error(f"Error processing moderator decision for callback {callback_query.data}: {e}")
        keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
        ])
        await callback_query.message.edit_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ä–µ—à–µ–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.", reply_markup=keyboard)

@router.message(F.text == "–ü–æ–¥–∫–ª—é—á–∏—Ç—å API")
async def connect_api(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    current_state = await state.get_state()
    logging.info(f"Processing '–ü–æ–¥–∫–ª—é—á–∏—Ç—å API' for user {user_id}, current state: {current_state}")

    cursor.execute("SELECT subscription_type, subscription_end, api_key FROM users WHERE user_id = %s", (user_id,))
    result = cursor.fetchone()

    if result and result['subscription_type'] == "referral_pending":
        keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
        ])
        await message.answer("‚è≥ –í–∞—à UUID –Ω–∞ –º–æ–¥–µ—Ä–∞—Ü–∏–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–∂–¥–∏—Ç–µ—Å—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.", reply_markup=keyboard)
        return

    if result and result['subscription_type'] == "referral_approved" and result['subscription_end'] > datetime.datetime.now():
        if result['api_key']:
            await message.answer(
                "‚úÖ –£ –≤–∞—Å —É–∂–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–Ω–∞ –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è. –í—ã –º–æ–∂–µ—Ç–µ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–¥–ø–∏—Å–∫–µ –∏–ª–∏ —Å–≤—è–∑–∞—Ç—å—Å—è —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –∫–ª—é—á–µ–π.",
                reply_markup=get_main_menu(user_id)
            )
            await state.clear()
            return
        if current_state in [PaymentStates.waiting_for_api_key, PaymentStates.waiting_for_secret_key, PaymentStates.waiting_for_passphrase]:
            if current_state == PaymentStates.waiting_for_api_key:
                await message.answer('''
–î–ª—è —Ç–æ–≥–æ, —á—Ç–æ–±—ã —É—Å–ø–µ—à–Ω–æ –ø—Ä–æ–≤–µ—Å—Ç–∏ –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—é, –≤–∞–º –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç –ø—Ä–∏—Å–ª–∞—Ç—å api –∫–ª—é—á –∏ secret key —Å –≤–∞—à–µ–π –±–∏—Ä–∂–∏. 
–í–ê–ñ–ù–û!
–ú—ã –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º –≤–∞—à–∏ –¥–∞–Ω–Ω—ã–µ –≤ –ª–∏—á–Ω—ã—Ö —Ü–µ–ª—è—Ö –∏ –Ω–µ –ø–µ—Ä–µ–¥–∞–µ–º –∏—Ö —Ç—Ä–µ—Ç—å–∏–º –ª–∏—Ü–∞–º! –í—Å–µ –¥–∞–Ω–Ω—ã–µ —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ –∑–∞—â–∏—â–µ–Ω–Ω–æ–π –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö, –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –∏—Ö —Ç–æ–ª—å–∫–æ –¥–ª—è —Ç–æ–≥–æ, —á—Ç–æ–±—ã –∏–º–µ—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø—Ä—è–º–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞ –∫–æ–º–∞–Ω–¥ –Ω–∞ –±–∏—Ä–∂—É.
–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞–ø–∏—à–∏—Ç–µ –≤–∞—à API –∫–ª—é—á:
''')
            elif current_state == PaymentStates.waiting_for_secret_key:
                await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à Secret Key:")
            elif current_state == PaymentStates.waiting_for_passphrase:
                await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à Passphrase:")
            return
        await state.clear()
        await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –±–∏—Ä–∂—É:", reply_markup=get_exchange_keyboard())
        await state.set_state(PaymentStates.waiting_for_api_key)
    else:
        await message.answer(
            "‚ùóÔ∏è –£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –ø–æ–¥–ø–∏—Å–∫–∏ –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –ø–æ–¥–ø–∏—Å–∫–∏:",
            reply_markup=get_subscription_type_keyboard()
        )
        await state.set_state(PaymentStates.waiting_for_subscription_type)

@router.message(F.text == "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–¥–ø–∏—Å–∫–µ")
async def subscription_info(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    current_state = await state.get_state()
    logging.info(f"Processing '–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–¥–ø–∏—Å–∫–µ' for user {user_id}, current state: {current_state}")

    cursor.execute("SELECT subscription_end, subscription_type, api_key, exchange FROM users WHERE user_id = %s", (user_id,))
    result = cursor.fetchone()

    if result and result['subscription_type'] == "referral_pending":
        keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
        ])
        await message.answer("‚è≥ –í–∞—à UUID –Ω–∞ –º–æ–¥–µ—Ä–∞—Ü–∏–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–∂–¥–∏—Ç–µ—Å—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.", reply_markup=keyboard)
        return

    if result and result['subscription_type'] == "referral_approved" and result['subscription_end'] is not None and result['subscription_end'] > datetime.datetime.now():
        subscription_end = result['subscription_end']
        subscription_type = result['subscription_type']
        api_status = "–ü–æ–¥–∫–ª—é—á–µ–Ω" if result['api_key'] else "–ù–µ –ø–æ–¥–∫–ª—é—á–µ–Ω"
        exchange = result['exchange'] or "–ù–µ –≤—ã–±—Ä–∞–Ω–∞"
        await message.answer(
            f"üìã –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–¥–ø–∏—Å–∫–µ:\n"
            f"–¢–∏–ø –ø–æ–¥–ø–∏—Å–∫–∏: –†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è (–ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞)\n"
            f"–ê–∫—Ç–∏–≤–Ω–∞ –¥–æ: {subscription_end.strftime('%Y-%m-%d %H:%M:%S')}\n"
            f"–ë–∏—Ä–∂–∞: {exchange}\n"
            f"API: {api_status}",
            parse_mode="HTML",
            reply_markup=get_main_menu(user_id)
        )
        await state.clear()
    else:
        await message.answer(
            "‚ùóÔ∏è –£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –ø–æ–¥–ø–∏—Å–∫–∏.",
            reply_markup=get_main_menu(user_id)
        )
        await state.set_state(PaymentStates.waiting_for_subscription_type)

@router.message(F.text == "üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞")
async def contact_support(message: types.Message, state: FSMContext):
    await message.answer(
        f"üìû –°–≤—è–∂–∏—Ç–µ—Å—å —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π: {SUPPORT_CONTACT}",
        reply_markup=get_main_menu(message.from_user.id)
    )

@router.message(PaymentStates.waiting_for_api_key)
async def process_api_key(message: types.Message, state: FSMContext):
    api_key = message.text.strip()
    user_id = message.from_user.id
    data = await state.get_data()
    exchange = data.get('exchange')

    if not exchange:
        logging.error(f"No exchange selected for user {user_id}")
        keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
        ])
        await message.answer("–û—à–∏–±–∫–∞: –±–∏—Ä–∂–∞ –Ω–µ –≤—ã–±—Ä–∞–Ω–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –±–∏—Ä–∂—É:", reply_markup=get_exchange_keyboard())
        return

    if len(api_key) < 10:
        logging.warning(f"Invalid API key length for user {user_id}: {api_key}")
        keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
        ])
        await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç API-–∫–ª—é—á–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π API-–∫–ª—é—á:", reply_markup=keyboard)
        return

    logging.info(f"API key received for user {user_id}: {api_key}")
    await state.update_data(api_key=api_key)
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –≤–∞—à Secret Key:")
    await state.set_state(PaymentStates.waiting_for_secret_key)

@router.message(PaymentStates.waiting_for_secret_key)
async def process_secret_key(message: types.Message, state: FSMContext):
    secret_key = message.text.strip()
    data = await state.get_data()
    user_id = message.from_user.id
    exchange = data.get('exchange')
    api_key = data.get('api_key')

    if len(secret_key) < 10:
        logging.warning(f"Invalid Secret Key length for user {user_id}: {secret_key}")
        keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
        ])
        await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç Secret Key. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π Secret Key:", reply_markup=keyboard)
        return

    logging.info(f"Secret key received for user {user_id}: {secret_key}")
    await state.update_data(secret_key=secret_key)

    if exchange == 'okx':
        await message.answer("–í–≤–µ–¥–∏—Ç–µ –≤–∞—à Passphrase:")
        await state.set_state(PaymentStates.waiting_for_passphrase)
    else:
        cursor.execute(
            "UPDATE users SET api_key = %s, secret_key = %s, passphrase = NULL, exchange = %s, chat_id = %s WHERE user_id = %s",
            (api_key, secret_key, exchange, user_id, user_id)
        )
        conn.commit()
        await message.answer(
            "‚úÖ –í—ã —É—Å–ø–µ—à–Ω–æ –ø–æ–¥–∫–ª—é—á–∏–ª–∏ –∞–≤—Ç–æ—Ç–æ—Ä–≥–æ–≤–ª—é!",
            reply_markup=get_main_menu(user_id)
        )
        await state.clear()
        logging.info(f"API keys successfully saved for user {user_id}, exchange: {exchange}")

@router.message(PaymentStates.waiting_for_passphrase)
async def process_passphrase(message: types.Message, state: FSMContext):
    passphrase = message.text.strip()
    data = await state.get_data()
    user_id = message.from_user.id
    exchange = data.get('exchange')
    api_key = data.get('api_key')
    secret_key = data.get('secret_key')

    if len(passphrase) < 8:
        logging.warning(f"Invalid Passphrase length for user {user_id}: {passphrase}")
        keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
        ])
        await message.answer(
            "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç Passphrase. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π Passphrase (–º–∏–Ω–∏–º—É–º 8 —Å–∏–º–≤–æ–ª–æ–≤):",
            reply_markup=keyboard
        )
        return

    logging.info(f"Passphrase received for user {user_id}: {passphrase}")
    cursor.execute(
        "UPDATE users SET api_key = %s, secret_key = %s, passphrase = %s, exchange = %s, chat_id = %s WHERE user_id = %s",
        (api_key, secret_key, passphrase, exchange, user_id, user_id)
    )
    conn.commit()

    await message.answer(
        "‚úÖ API-–∫–ª—é—á –∏ Passphrase —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω—ã! –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∞.",
        reply_markup=get_main_menu(user_id)
    )
    await state.clear()
    logging.info(f"API keys and passphrase successfully saved for user {user_id}, exchange: {exchange}")

@router.callback_query(F.data == "cancel")
async def cancel_action(callback_query: types.CallbackQuery, state: FSMContext):
    await callback_query.message.delete()
    await bot.send_message(
        callback_query.from_user.id,
        "–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.",
        reply_markup=get_main_menu(callback_query.from_user.id)
    )
    await state.clear()

@router.message(lambda message: message.text not in ["–ü–æ–¥–∫–ª—é—á–∏—Ç—å API", "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–¥–ø–∏—Å–∫–µ", "üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞"])
async def handle_invalid_input(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    current_state = await state.get_state()
    logging.info(f"Invalid input from user {user_id}, state: {current_state}, input: {message.text}")

    cursor.execute("SELECT subscription_type, subscription_end FROM users WHERE user_id = %s", (user_id,))
    result = cursor.fetchone()

    if current_state == PaymentStates.waiting_for_api_key:
        await process_api_key(message, state)
        return
    elif current_state == PaymentStates.waiting_for_secret_key:
        await process_secret_key(message, state)
        return
    elif current_state == PaymentStates.waiting_for_passphrase:
        await process_passphrase(message, state)
        return
    elif current_state == PaymentStates.waiting_for_referral_uuid:
        await process_referral_uuid(message, state)
        return
    elif result and result['subscription_type'] == "referral_approved" and result['subscription_end'] > datetime.datetime.now():
        await message.answer(
            "‚úÖ –£ –≤–∞—Å –µ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞. –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
            reply_markup=get_main_menu(user_id)
        )
        await state.clear()
    else:
        keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
        ])
        await message.answer(
            "‚ùóÔ∏è –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å –±–æ—Ç–æ–º.",
            reply_markup=keyboard
        )
        await state.clear()

# –ó–∞–º–µ–Ω—è–µ–º —Ñ—É–Ω–∫—Ü–∏—é send_signal_notification –≤ main.py

async def send_signal_notification(signal: dict, user_id: int):
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –Ω–æ–≤–æ–º —Å–∏–≥–Ω–∞–ª–µ –∏–ª–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ —Å–¥–µ–ª–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é."""
    action = signal['action']
    symbol = signal['symbol']
    price = signal['price']
    stop_loss = signal['stop_loss']
    take_profits = [signal.get('take_profit_1'), signal.get('take_profit_2'), signal.get('take_profit_3')]

    SUPPORT_CONTACT = os.getenv("SUPPORT_CONTACT", "@SupportBot")
    keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
        [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
    ])

    if action.startswith("CLOSE_"):
        side = action.split("_")[1]
        message = (
            f"üîî <b>–°–¥–µ–ª–∫–∞ {side} –∑–∞–∫—Ä—ã—Ç–∞</b>\n"
            f"üìä –ü–∞—Ä–∞: {symbol}\n"
            f"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ —Å—Ç–∞—Ç—É—Å –Ω–∞ –±–∏—Ä–∂–µ. –ï—Å–ª–∏ –≤–æ–∑–Ω–∏–∫–ª–∏ –ø—Ä–æ–±–ª–µ–º—ã, —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π!"
        )
    else:
        tp1, tp2, tp3 = take_profits
        message = (
            f"üîî <b>–û—Ç–∫—Ä—ã—Ç —Å–∏–≥–Ω–∞–ª</b>\n"
            f"üìä –ü–∞—Ä–∞: {symbol}\n"
            f"üí∞ –¶–µ–Ω–∞ –≤—Ö–æ–¥–∞: {price}\n"
            f"üéØ –¢–µ–π–∫-–ø—Ä–æ—Ñ–∏—Ç 1: {tp1}\n"
            f"üéØ –¢–µ–π–∫-–ø—Ä–æ—Ñ–∏—Ç 2: {tp2}\n"
            f"üéØ –¢–µ–π–∫-–ø—Ä–æ—Ñ–∏—Ç 3: {tp3}\n"
            f"üõë –°—Ç–æ–ø-–ª–æ—Å—Å: {stop_loss}\n\n"
            f"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ, –≤—Å–µ –ª–∏ –æ—Ç–∫—Ä—ã—Ç–æ –Ω–∞ –±–∏—Ä–∂–µ. –ï—Å–ª–∏ –≤–æ–∑–Ω–∏–∫–ª–∏ –ø—Ä–æ–±–ª–µ–º—ã, –Ω–∞–ø–∏—à–∏—Ç–µ –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É!"
        )

    try:
        await bot.send_message(
            chat_id=user_id,
            text=message,
            parse_mode="HTML",
            reply_markup=keyboard
        )
        logging.info(f"–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}: {action}")
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}: {str(e)}")

async def check_subscriptions():
    while True:
        now = datetime.datetime.now()
        cursor.execute("SELECT user_id FROM users WHERE subscription_end < %s", (now,))
        expired_users = cursor.fetchall()

        for user in expired_users:
            user_id = user['user_id']
            try:
                member = await bot.get_chat_member(chat_id=GROUP_ID, user_id=user_id)
                if member.status not in [ChatMemberStatus.LEFT, ChatMemberStatus.KICKED]:
                    await bot.ban_chat_member(chat_id=GROUP_ID, user_id=user_id)
                cursor.execute("DELETE FROM users WHERE user_id = %s", (user_id,))
                conn.commit()
                try:
                    keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
                        [types.InlineKeyboardButton(text="üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"https://t.me/{SUPPORT_CONTACT.lstrip('@')}")]
                    ])
                    await bot.send_message(user_id, "–í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ –∏—Å—Ç–µ–∫–ª–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–¥–ª–∏—Ç–µ –µ—ë.", reply_markup=keyboard)
                except TelegramBadRequest as send_error:
                    logging.warning(f"Could not send expiration message to user {user_id}: {send_error}")
            except TelegramForbiddenError:
                logging.warning(f"Bot was blocked by user {user_id}. Removing from DB.")
                cursor.execute("DELETE FROM users WHERE user_id = %s", (user_id,))
                conn.commit()
            except Exception as processing_error:
                logging.error(f"Error processing expired subscription for user {user_id}: {processing_error}")
        await asyncio.sleep(3600)

async def check_payment_status():
    while True:
        try:
            cursor.execute("SELECT invoice_id, user_id, amount, tariff_id FROM payments WHERE status = %s", ("pending",))
            pending_invoices = cursor.fetchall()

            async with aiohttp.ClientSession() as session:
                url = "https://pay.crypt.bot/api/getInvoices"
                headers = {"Crypto-Pay-API-Token": CRYPTO_BOT_TOKEN}
                for invoice in pending_invoices:
                    invoice_id = invoice['invoice_id']
                    user_id = invoice['user_id']
                    amount = invoice['amount']
                    tariff_id = invoice.get('tariff_id')
                    if not tariff_id:
                        logging.warning(f"tariff_id not found for invoice {invoice_id}, skipping")
                        continue
                    params = {"invoice_ids": invoice_id}
                    try:
                        async with session.get(url, headers=headers, params=params) as response:
                            if response.status != 200:
                                logging.error(f"CryptoBot API error for invoice {invoice_id}: {response.status}")
                                continue
                            data = await response.json()
                            if data.get("ok") and data.get("result", {}).get("items"):
                                invoice_status = data["result"]["items"][0]["status"]
                                if invoice_status == "paid":
                                    tariff = TARIFFS.get(tariff_id)
                                    if tariff:
                                        subscription_end = datetime.datetime.now() + datetime.timedelta(days=tariff['days'])
                                        cursor.execute(
                                            "UPDATE users SET subscription_end = %s, subscription_type = %s WHERE user_id = %s",
                                            (subscription_end, "regular", user_id)
                                        )
                                        cursor.execute(
                                            "UPDATE payments SET status = %s WHERE invoice_id = %s",
                                            ("completed", invoice_id)
                                        )
                                        conn.commit()
                                        try:
                                            await bot.send_message(
                                                user_id,
                                                f"‚úÖ –û–ø–ª–∞—Ç–∞ –Ω–∞ {amount} USDT –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞!\n"
                                                f"–í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ –∞–∫—Ç–∏–≤–Ω–∞ –¥–æ {subscription_end.strftime('%Y-%m-%d %H:%M:%S')}",
                                                reply_markup=get_main_menu(user_id)
                                            )
                                        except TelegramBadRequest as e:
                                            logging.error(f"Failed to notify user {user_id} about payment: {e}")
                                elif invoice_status in ["expired", "failed"]:
                                    cursor.execute(
                                        "UPDATE payments SET status = %s WHERE invoice_id = %s",
                                        (invoice_status, invoice_id)
                                    )
                                    conn.commit()
                                    try:
                                        await bot.send_message(
                                            user_id,
                                            "‚ùå –°—á—ë—Ç –∏—Å—Ç—ë–∫ –∏–ª–∏ –Ω–µ –±—ã–ª –æ–ø–ª–∞—á–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Ç–∞—Ä–∏—Ñ —Å–Ω–æ–≤–∞:",
                                            reply_markup=get_tariffs_keyboard()
                                        )
                                    except TelegramBadRequest as e:
                                        logging.error(f"Failed to notify user {user_id} about expired invoice: {e}")
                    except aiohttp.ClientError as e:
                        logging.error(f"Network error checking invoice {invoice_id}: {e}")
        except Exception as e:
            logging.error(f"Error in check_payment_status: {e}")
        await asyncio.sleep(60)

async def main():
    is_in_group = await is_bot_in_group()
    if not is_in_group:
        logging.error("–ë–æ—Ç –Ω–µ —Å–æ—Å—Ç–æ–∏—Ç –≤ –≥—Ä—É–ø–ø–µ –∏–ª–∏ –Ω–µ –∏–º–µ–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")
        print("‚ùå –ë–æ—Ç –Ω–µ —Å–æ—Å—Ç–æ–∏—Ç –≤ –≥—Ä—É–ø–ø–µ –∏–ª–∏ –Ω–µ –∏–º–µ–µ—Ç –¥–æ—Å—Ç—É–ø–∞. –î–æ–±–∞–≤—å—Ç–µ –±–æ—Ç–∞ –≤ –≥—Ä—É–ø–ø—É –∏ –Ω–∞–∑–Ω–∞—á—å—Ç–µ –µ–≥–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.")
        return

    asyncio.create_task(check_subscriptions())
    asyncio.create_task(check_payment_status())
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())